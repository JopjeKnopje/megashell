/* ************************************************************************** */
/*                                                                            */
/*                                                       ::::::::             */
/*   aliases.c                                         :+:    :+:             */
/*                                                    +:+                     */
/*   By: joppe <jboeve@student.codam.nl>             +#+                      */
/*                                                  +#+                       */
/*   Created: 2023/08/28 18:10:22 by joppe         #+#    #+#                 */
/*   Updated: 2023/08/29 10:34:52 by joppe         ########   odam.nl         */
/*                                                                            */
/* ************************************************************************** */


#include "get_next_line.h"
#include "libft.h"
#include "megashell.h"
#include "execute.h"
#include "test_utils.h"
#include <errno.h>
#include <fcntl.h>
#include <readline/readline.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/wait.h>
#include <unistd.h>


#define PIPE_READ 0
#define PIPE_WRITE 1

/**
 * NOTES
 * We can't run bash in interactive mode because it will show a prompt,
 * even if we run it in a pipe.
 *
 * So we can try to find an other way to read the aliases.
 * [Or try to disable the readline prompt generated by bash running in the child.] 
 * 
 * maybe quickly clear the prompt after doing the whole alias call?
 *
 *
 */

void aliases_init(t_meta *meta)
{
	int to_child[2];
	int from_child[2];
	pipe(to_child);
	pipe(from_child);

	int pid = fork();
	if (pid == 0)
	{
		if (dup2(to_child[PIPE_READ], STDIN_FILENO) == -1)
		{
			perror(strerror(errno));
			printf("dup failed\n");
		}
		if (dup2(from_child[PIPE_WRITE], STDOUT_FILENO) == -1)
		{
			perror(strerror(errno));
			printf("dup failed\n");
		}
		close(to_child[PIPE_WRITE]);
		close(from_child[PIPE_READ]);


		char *argv[] = {
			"bash",
			"-i",
			"-s",
			NULL
		};
		execve("/usr/bin/bash", argv, meta->envp);
	}
	close(to_child[PIPE_READ]);
	close(from_child[PIPE_WRITE]);


	char *buf = "alias\n";
	write(to_child[PIPE_WRITE], buf, ft_strlen(buf));


	int outfile = open("outfile.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (outfile == -1)
	{
		printf("failed opening file\n");
	}
	
	int32_t size = 256;
	char read_data[size];
	while (true)
	{
		ft_bzero(&read_data, size);
		int err = read(from_child[PIPE_READ], &read_data, size - 1);

		// fprintf(stderr, "%s", read_data);
		write(outfile, read_data, size);
		if (err < size - 1)
			break;
	}



	close(to_child[PIPE_WRITE]);
	close(from_child[PIPE_READ]);
	waitpid(pid, NULL, 0);

}
